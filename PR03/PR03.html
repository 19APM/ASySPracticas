<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Pr&aacute;ctica 3: Se&ntilde;ales en tiempo continuo</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-18">
<meta name="DC.source" content="PR03.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Pr&aacute;ctica 3: Se&ntilde;ales en tiempo continuo</h1>
<!--introduction-->
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Integrantes</a>
</li>
<li>
<a href="#2">Objetivos</a>
</li>
<li>
<a href="#3">Introducci&oacute;n</a>
</li>
<li>
<a href="#4">Desarrollo</a>
</li>
<li>
<a href="#5">Problema 1</a>
</li>
</ul>
</div>
<h2 id="1">Integrantes</h2>
<p>Portillo Mart&iacute;nez Arturo</p>
<h2 id="2">Objetivos</h2>
<div>
<ul>
<li>Manipulaci&oacute;n b&aacute;sica de MATLAB.</li>
<li>Gr&aacute;ficas de se&ntilde;ales reales y complejas continuas.</li>
<li>Transformaci&oacute;n de se&ntilde;ales continuas (escalamientos y traslaciones).</li>
<li>Clculo de energ&iacute;a y potencia de se&ntilde;ales continuas.</li>
</ul>
</div>
<h2 id="3">Introducci&oacute;n</h2>
<p>Se realiz&oacute; la investigaci&oacute;n del uso de Python para la realizaci&oacute;n de gr&aacute;ficas, a continuaci&oacute;n se muestran las gr&aacute;ficas correspondientes al problema 4 mediante Python.</p>
<p>
<img vspace="5" hspace="5" src="C:\Users\porti\OneDrive\Escritorio\Se%C3%B1ales y Sistemas\PR03\html\intro.png" alt=""> </p>
<p>Se puede consultar el c&oacute;digo realizado con Python en el siguiente <a href="https://colab.research.google.com/drive/1XnKYDQmnbECtDmMwu0-lw2WxHoELL3KE?usp=sharing">enlace</a>.</p>
<h2 id="4">Desarrollo</h2>
<p>A continuaci&oacute;n se realizar&aacute; el desarrollo de los siguientes problemas planteados para entregar en la pr&aacute;ctica.</p>
<p>
<b>1.</b> Reproducir la secci&oacute;n 1.11 del libro de Lathi (versi&oacute;n de clase).</p>
<p>
<b>2.</b> Resolver el problema 1.2-2 usando las herramientas del problema anterior. <b>3.</b> Resolver el problema 1.11-1, los ejes deben mostrarse en el origen adem&aacute;s de la edici&oacute;n de tu preferencia.</p>
<p>
<b>4.</b> Construye la gr&aacute;fica de: <img src="PR03_eq01254418086591493464.png" alt="$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$"> para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen ademas de la edici&oacute;n de su preferencia.</p>
<p>
<b>5.</b> Resolver el problema 1.11-3, agregar como inciso (e) la gr&aacute;fica de <img src="PR03_eq12659395712222829305.png" alt="$x(t)$"> para <img src="PR03_eq16434444273656135249.png" alt="$t\in[-10,10]$">.</p>
<p>
<b>6.</b> Construir una app que permita:</p>
<div>
<ul>
<li>Gr&aacute;ficar se&ntilde;ales en tiempo continuo reales, el usuario ingresa la definici&oacute;n de la se&ntilde;al en el formato especifico.</li>
<li>El usuario puede definir el intervalo de la gr&aacute;fica.</li>
<li>El usuario puede seleccionar el tipo de transformaci&oacute;n (horizontal, vertical o combinaci&oacute;n) que desee realizar a la se&ntilde;al, la app deber&aacute; mostrar la gr&aacute;fica de esta transformaci&oacute;n.</li>
<li>Se adjunta una imagen de la app a la pr&aacute;ctica, y el archivo de la app.</li>
</ul>
</div>
<p>No es necesario incluir conclusiones en esta pr&aacute;ctica, si lo considera necesario puede incluir ap&eacute;ndices, no olvide incluir sus referencias.</p>
<h2 id="5">Problema 1</h2>
<p>Reproducir la secci&oacute;n 1.11 del libro de Lathi (versi&oacute;n de clase). La versi&oacute;n utilizada en clase es la tercera edici&oacute;n.</p>
<p>1.11 MATLAB: Trabajando con funciones</p>
<p>Trabajar con funciones es fundamental para las aplicaciones de se&ntilde;ales y sistemas. MATLAB proporciona varios m&eacute;todos para definir y evaluar funciones. La comprensi&oacute;n y el uso competente de estos m&eacute;todos son, por tanto, necesarios y beneficiosos.</p>
<p>1.11-1 Funciones an&oacute;nimas</p>
<p>Muchas funciones simples se representan convenientemente mediante el uso an&oacute;nimo de MATLAB. Una funci&oacute;n an&oacute;nima proporciona una representaci&oacute;n simb&oacute;lica de una funci&oacute;n definida en t&eacute;rminos de operadores, funciones u otras funciones an&oacute;nimas de MATLAB. Por ejemplo, considere definir la sinusoide amortiguada exponencialmente <img src="PR03_eq17807686604900783746.png" alt="$f(t) = e^{-t} cos(2\pi  t)$">.</p>
<pre class="codeinput">f = @(t) exp(-t).*cos(2*pi*t);
</pre>
<p>En este contexto, el s&iacute;mbolo @ identifica la expresi&oacute;n como una funci&oacute;n an&oacute;nima, que se asigna un nombre de f. Los par&eacute;ntesis que siguen al s&iacute;mbolo @ se utilizan para identificar la funci&oacute;n independiente. variables (argumentos de entrada), que en este caso es la &uacute;nica variable de tiempo t. Argumentos de entrada, como como t, son locales de la funci&oacute;n an&oacute;nima y no est&aacute;n relacionados con ninguna variable del espacio de trabajo con la mismos nombres.</p>
<p>Una vez definida, f (t) se puede evaluar simplemente pasando los valores de entrada de inter&eacute;s. Por ejemplo:</p>
<pre class="codeinput">t = 0; f(t)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>eval&uacute;a f(t) en t = 0, confirmando el resultado esperado de la unidad. El mismo resultado se obtiene pasando t = 0 directamente.</p>
<pre class="codeinput">f(0)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>Las entradas vectoriales permiten la evaluaci&oacute;n de m&uacute;ltiples valores simult&aacute;neamente. Considere la tarea de trazar f(t) en el intervalo <img src="PR03_eq18236345434950197352.png" alt="$(-2 <= t <= 2)$">. El comportamiento de la funci&oacute;n bruta es claro: f(t) deber&iacute;a oscilar cuatro veces con una envolvente en decayente. Dado que los bocetos precisos a mano son engorrosos, los gr&aacute;ficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, se deben tomar medidas para garantizar resultados confiables. Supongamos que se elige el vector t para incluir solo los n&uacute;meros enteros contenidos en <img src="PR03_eq18236345434950197352.png" alt="$(-2 <= t <= 2)$">, es decir, <img src="PR03_eq00323666827583285953.png" alt="$[-2,-1, 0, 1,2]$">.</p>
<pre class="codeinput">t = (-2:2);
</pre>
<p>Esta entrada vectorial se eval&uacute;a para formar una salida vectorial.</p>
<pre class="codeinput">f(t)
</pre>
<pre class="codeoutput">
ans =

    7.3891    2.7183    1.0000    0.3679    0.1353

</pre>
<p>El comando de trazado grafica el resultado, que se muestra:</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'f(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="PR03_01.png" alt=""> <p>Las l&iacute;neas de cuadr&iacute;cula, agregadas mediante el comando de cuadr&iacute;cula, ayudan a identificar las caracter&iacute;sticas. Desafortunadamente, el gr&aacute;fico no ilustra el comportamiento oscilatorio esperado. Se requieren m&aacute;s puntos para adecuadamente representar f(t).</p>
<p>La pregunta entonces es &iquest;cu&aacute;ntos puntos son suficientes? Si se eligen muy pocos puntos, la informaci&oacute;n est&aacute; perdida. Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio. Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilaci&oacute;n. Para el presente en este caso, se elige t para dar 100 puntos por oscilaci&oacute;n.</p>
<pre class="codeinput">t = (-2:0.01:2);
</pre>
<p>La funci&oacute;n es de nuevo evaluada y graficada:</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'f(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="PR03_02.png" alt=""> <p>1.11-2 Operadores relacionales y la funci&oacute;n de paso unitario</p>
<p>La funci&oacute;n escal&oacute;n unitario u(t) surge naturalmente en muchas situaciones pr&aacute;cticas. Por ejemplo, un escal&oacute;n unitario puede modelar el acto de encender un sistema. Con la ayuda de operadores relacionales, funciones an&oacute;nimas puede representar la funci&oacute;n de escal&oacute;n unitario.</p>
<p>En MATLAB, un operador relacional compara dos elementos. Si la comparaci&oacute;n es cierta, una verdad l&oacute;gica (1) se devuelve. Si la comparaci&oacute;n es falsa, se devuelve un falso l&oacute;gico (0). A veces llamado indicador de funciones, los operadores relacionales indican si una condici&oacute;n es verdadera. Seis operadores relacionales disponibles: &lt;, &gt;, &lt;=, &gt;=, ==, y ~=.</p>
<p>La funci&oacute;n de escal&oacute;n unitario se define f&aacute;cilmente utilizando el operador relacional &gt;=.</p>
<pre class="codeinput">u = @(t) 1.0.*(t&gt;=0);
</pre>
<p>Cualquier funci&oacute;n con una discontinuidad de salto, como el escal&oacute;n unitario, es dif&iacute;cil de trazar. Considere la posibilidad de trazar u(t) usando t = (-2:2).</p>
<pre class="codeinput">t = (-2:2); plot(t,u(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'u(t)'</span>);
</pre>
<img vspace="5" hspace="5" src="PR03_03.png" alt=""> <p>Dos problemas importantes son evidentes en el gr&aacute;fico resultante, que se muestra. Primero, MATLAB escala autom&aacute;ticamente los ejes del gr&aacute;fico para vincular estrechamente los datos. Normalmente, en este caso, la caracter&iacute;stica deseable oscurece la mayor parte de la trama. En segundo lugar, MATLAB conecta los datos del trazado con l&iacute;neas, haciendo que una verdadera discontinuidad de salto sea dif&iacute;cil de lograr. La resoluci&oacute;n gruesa del vector t enfatiza el efecto al mostrar una l&iacute;nea inclinada err&oacute;nea entre t=&minus;1 y t = 0. El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje dominio. El segundo problema se reduce, pero no se elimina, sumando puntos al vector t.</p>
<pre class="codeinput">t = (-2:0.01:2); plot(t,u(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'u(t)'</span>);
axis([-2 2 -0.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="PR03_04.png" alt=""> <p>El argumento vectorial de cuatro elementos del eje especifica el eje x m&iacute;nimo, el eje x m&aacute;ximo, el eje y m&iacute;nimo y el m&aacute;ximo del eje y, respectivamente. Como se puede obserbar en la gr&aacute;fica anterior.</p>
<p>Los operadores relacionales se pueden combinar usando AND l&oacute;gico, O l&oacute;gico y negaci&oacute;n l&oacute;gica: &amp;, | y ~, respectivamente. Por ejemplo, (t&gt;0)&amp;(t&lt;1) y ~((t&lt;=0)|(t&gt;=1)) prueban si 0&lt;t &lt;1. Para demostrarlo, considere definir y trazar el pulso unitario p(t) = u(t)&minus;u(t &minus;1), como se muestra:</p>
<pre class="codeinput">p = @(t) 1.0.*((t&gt;=0)&amp;(t&lt;1));
t = (-1:0.01:2); plot(t,p(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'p(t) = u(t)-u(t-1)'</span>);
axis([-1 2 -.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="PR03_05.png" alt=""> <p>Para operandos escalares, MATLAB tambi&eacute;n admite dos construcciones l&oacute;gicas de cortocircuito. El AND l&oacute;gico de cortocircuito se realiza mediante &amp;&amp;, y el OR l&oacute;gico de cortocircuito se realiza usando. Los operadores l&oacute;gicos de cortocircuito suelen ser m&aacute;s eficientes que los operadores l&oacute;gicos tradicionales porque prueban la segunda parte de la expresi&oacute;n s&oacute;lo cuando es necesario. Es decir, cuandouna expresi&oacute;n escalar A se encuentra falsa en (A&amp;&amp;B), la expresi&oacute;n escalar B no se eval&uacute;a, ya que un resultado falso ya est&aacute; garantizado. De manera similar, la expresi&oacute;n escalar B no se eval&uacute;a cuando la expresi&oacute;n escalar A es encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.</p>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Práctica 3: Señales en tiempo continuo
%
%
%% Integrantes
%
% Portillo Martínez Arturo
%
%% Objetivos
%
% * Manipulación básica de MATLAB.
% * Gráficas de señales reales y complejas continuas.
% * Transformación de señales continuas (escalamientos y traslaciones).
% * Clculo de energía y potencia de señales continuas.
%
%% Introducción
%
% Se realizó la investigación del uso de Python para la realización de
% gráficas, a continuación se muestran las gráficas correspondientes al problema 4 mediante Python.
% 
% <<C:\Users\porti\OneDrive\Escritorio\Señales y Sistemas\PR03\html\intro.png>>
%
% Se puede consultar el código realizado con Python en el siguiente <https://colab.research.google.com/drive/1XnKYDQmnbECtDmMwu0-lw2WxHoELL3KE?usp=sharing enlace>. 
%
%% Desarrollo
%
% A continuación se realizará el desarrollo de los siguientes problemas
% planteados para entregar en la práctica.
% 
% *1.* Reproducir la sección 1.11 del libro de Lathi (versión de clase).
%
% *2.* Resolver el problema 1.2-2 usando las herramientas del problema
% anterior.
% *3.* Resolver el problema 1.11-1, los ejes deben mostrarse en el origen
% además de la edición de tu preferencia.
%
% *4.* Construye la gráfica de: $$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$  para cuatro rangos (figura 2x2).
% Los ejes deben mostrarse en el origen ademas de la edición de su preferencia.
%
% *5.* Resolver el problema 1.11-3, agregar como inciso (e) la gráfica de
% $x(t)$ para $t\in[-10,10]$.
%
% *6.* Construir una app que permita:
%
% * Gráficar señales en tiempo continuo reales, el usuario ingresa la
% definición de la señal en el formato especifico.
% * El usuario puede definir el intervalo de la gráfica.
% * El usuario puede seleccionar el tipo de transformación (horizontal,
% vertical o combinación) que desee realizar a la señal, la app deberá
% mostrar la gráfica de esta transformación.
% * Se adjunta una imagen de la app a la práctica, y el archivo de la app.
%
% No es necesario incluir conclusiones en esta práctica, si lo considera
% necesario puede incluir apéndices, no olvide incluir sus referencias.
%
%% Problema 1
%
% Reproducir la sección 1.11 del libro de Lathi (versión de clase).
% La versión utilizada en clase es la tercera edición.
% 
% 1.11 MATLAB: Trabajando con funciones
%
% Trabajar con funciones es fundamental para las aplicaciones de señales y sistemas. MATLAB proporciona varios métodos para definir y evaluar funciones. La comprensión y el uso competente de estos métodos son, por tanto, necesarios y beneficiosos.
%
%
% 1.11-1 Funciones anónimas
%
% Muchas funciones simples se representan convenientemente mediante el uso anónimo de MATLAB.
% Una función anónima proporciona una representación simbólica de una función definida en términos de operadores, funciones u otras funciones anónimas de MATLAB. 
% Por ejemplo, considere definir la sinusoide amortiguada exponencialmente
% $$f(t) = e^{-t} cos(2\pi  t)$$.
f = @(t) exp(-t).*cos(2*pi*t);

%% 
% En este contexto, el símbolo @ identifica la expresión como una función anónima, que se asigna
% un nombre de f. Los paréntesis que siguen al símbolo @ se utilizan para identificar la función independiente.
% variables (argumentos de entrada), que en este caso es la única variable de tiempo t. Argumentos de entrada, como
% como t, son locales de la función anónima y no están relacionados con ninguna variable del espacio de trabajo con la
% mismos nombres.
%
% Una vez definida, f (t) se puede evaluar simplemente pasando los valores
% de entrada de interés. Por ejemplo:
t = 0; f(t)

%%
% evalúa f(t) en t = 0, confirmando el resultado esperado de la unidad. El mismo resultado se obtiene pasando t = 0 directamente.
f(0)

%%
% Las entradas vectoriales permiten la evaluación de múltiples valores simultáneamente.
% Considere la tarea de trazar f(t) en el intervalo $$(-2 <= t <= 2)$$.
% El comportamiento de la función bruta es claro: f(t) debería oscilar cuatro veces con una envolvente en decayente.
% Dado que los bocetos precisos a mano son engorrosos, los gráficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, se deben tomar medidas para garantizar resultados confiables.
% Supongamos que se elige el vector t para incluir solo los números enteros contenidos en $$(-2 <= t <= 2)$$, es decir, $$[-2,-1, 0, 1,2]$$.
t = (-2:2);

%%
% Esta entrada vectorial se evalúa para formar una salida vectorial.
f(t)

%%
% El comando de trazado grafica el resultado, que se muestra:
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;

%%
% Las líneas de cuadrícula, agregadas mediante el comando de cuadrícula, ayudan a identificar las características. 
% Desafortunadamente, el gráfico no ilustra el comportamiento oscilatorio esperado. 
% Se requieren más puntos para adecuadamente representar f(t).
%
% La pregunta entonces es ¿cuántos puntos son suficientes? Si se eligen muy pocos puntos, la información está perdida. 
% Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio. 
% Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilación. 
% Para el presente en este caso, se elige t para dar 100 puntos por oscilación.
t = (-2:0.01:2);

%%
% La función es de nuevo evaluada y graficada:
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;

%%
% 1.11-2 Operadores relacionales y la función de paso unitario
% 
% La función escalón unitario u(t) surge naturalmente en muchas situaciones prácticas. 
% Por ejemplo, un escalón unitario puede modelar el acto de encender un sistema. 
% Con la ayuda de operadores relacionales, funciones anónimas puede representar la función de escalón unitario.
%
% En MATLAB, un operador relacional compara dos elementos. 
% Si la comparación es cierta, una verdad lógica (1) se devuelve. 
% Si la comparación es falsa, se devuelve un falso lógico (0). 
% A veces llamado indicador de funciones, los operadores relacionales indican si una condición es verdadera. 
% Seis operadores relacionales disponibles: <, >, <=, >=, ==, y ~=.
%
% La función de escalón unitario se define fácilmente utilizando el operador relacional >=.
u = @(t) 1.0.*(t>=0);

%%
% Cualquier función con una discontinuidad de salto, como el escalón unitario, es difícil de trazar. 
% Considere la posibilidad de trazar u(t) usando t = (-2:2).
t = (-2:2); plot(t,u(t));
xlabel('t'); ylabel('u(t)');

%%
% Dos problemas importantes son evidentes en el gráfico resultante, que se
% muestra. Primero, MATLAB escala automáticamente los ejes del gráfico para vincular estrechamente los datos. 
% Normalmente, en este caso, la característica deseable oscurece la mayor parte de la trama. 
% En segundo lugar, MATLAB conecta los datos del trazado con líneas, haciendo que una verdadera discontinuidad de salto sea difícil de lograr.
% La resolución gruesa del vector t enfatiza el efecto al mostrar una línea inclinada errónea entre t=−1 y t = 0.
% El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje dominio. 
% El segundo problema se reduce, pero no se elimina, sumando puntos al vector t.
t = (-2:0.01:2); plot(t,u(t));
xlabel('t'); ylabel('u(t)');
axis([-2 2 -0.1 1.1]);

%%
% El argumento vectorial de cuatro elementos del eje especifica el eje x mínimo, el eje x máximo, el eje y mínimo y el máximo del eje y, respectivamente. 
% Como se puede obserbar en la gráfica anterior.
%
% Los operadores relacionales se pueden combinar usando AND lógico, O lógico y negación lógica: &, | y ~, respectivamente. 
% Por ejemplo, (t>0)&(t<1) y ~((t<=0)|(t>=1)) prueban si 0<t <1.
% Para demostrarlo, considere definir y trazar el pulso unitario p(t) =
% u(t)−u(t −1), como se muestra:
p = @(t) 1.0.*((t>=0)&(t<1));
t = (-1:0.01:2); plot(t,p(t));
xlabel('t'); ylabel('p(t) = u(t)-u(t-1)');
axis([-1 2 -.1 1.1]);

%%
% Para operandos escalares, MATLAB también admite dos construcciones lógicas de cortocircuito.
% El AND lógico de cortocircuito se realiza mediante &&, y el OR lógico de cortocircuito se realiza usando ||. 
% Los operadores lógicos de cortocircuito suelen ser más eficientes que los operadores lógicos tradicionales porque prueban la segunda parte de la expresión sólo cuando es necesario. 
% Es decir, cuandouna expresión escalar A se encuentra falsa en (A&&B), la expresión escalar B no se evalúa, ya que un resultado falso ya está garantizado. 
% De manera similar, la expresión escalar B no se evalúa cuando la expresión escalar A es encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.
##### SOURCE END #####
-->
</body>
</html>
