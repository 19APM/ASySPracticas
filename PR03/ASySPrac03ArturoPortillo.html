<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Pr&aacute;ctica 3: Se&ntilde;ales en tiempo continuo</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-18">
<meta name="DC.source" content="PR03.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Pr&aacute;ctica 3: Se&ntilde;ales en tiempo continuo</h1>
<!--introduction-->
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Integrantes</a>
</li>
<li>
<a href="#2">Objetivos</a>
</li>
<li>
<a href="#3">Introducci&oacute;n</a>
</li>
<li>
<a href="#4">Desarrollo</a>
</li>
<li>
<a href="#5">Problema 1</a>
</li>
<li>
<a href="#30">Problema 2</a>
</li>
<li>
<a href="#32">Problema 3</a>
</li>
<li>
<a href="#34">Problema 4</a>
</li>
<li>
<a href="#35">Problema 5</a>
</li>
<li>
<a href="#41">Problema 6</a>
</li>
</ul>
</div>
<h2 id="1">Integrantes</h2>
<p>Portillo Mart&iacute;nez Arturo</p>
<h2 id="2">Objetivos</h2>
<div>
<ul>
<li>Manipulaci&oacute;n b&aacute;sica de MATLAB.</li>
<li>Gr&aacute;ficas de se&ntilde;ales reales y complejas continuas.</li>
<li>Transformaci&oacute;n de se&ntilde;ales continuas (escalamientos y traslaciones).</li>
<li>C&aacute;lculo de energ&iacute;a y potencia de se&ntilde;ales continuas.</li>
</ul>
</div>
<h2 id="3">Introducci&oacute;n</h2>
<p>Se realiz&oacute; la investigaci&oacute;n del uso de Python para la realizaci&oacute;n de gr&aacute;ficas, a continuaci&oacute;n se muestran las gr&aacute;ficas correspondientes al problema 4 mediante Python.</p>
<p>
<img vspace="5" hspace="5" src="intro.png" alt=""> </p>
<p>Se puede consultar el c&oacute;digo realizado con Python en el siguiente <a href="https://colab.research.google.com/drive/1XnKYDQmnbECtDmMwu0-lw2WxHoELL3KE?usp=sharing">enlace</a>.</p>
<h2 id="4">Desarrollo</h2>
<p>A continuaci&oacute;n se realizar&aacute; el desarrollo de los siguientes problemas planteados para entregar en la pr&aacute;ctica.</p>
<p>
<b>1.</b> Reproducir la secci&oacute;n 1.11 del libro de Lathi (versi&oacute;n de clase).</p>
<p>
<b>2.</b> Resolver el problema 1.2-2 usando las herramientas del problema anterior. <b>3.</b> Resolver el problema 1.11-1, los ejes deben mostrarse en el origen adem&aacute;s de la edici&oacute;n de tu preferencia.</p>
<p>
<b>4.</b> Construye la gr&aacute;fica de: <img src="PR03_eq01254418086591493464.png" alt="$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$"> para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen ademas de la edici&oacute;n de su preferencia.</p>
<p>
<b>5.</b> Resolver el problema 1.11-3, agregar como inciso (e) la gr&aacute;fica de <img src="PR03_eq12659395712222829305.png" alt="$x(t)$"> para <img src="PR03_eq16434444273656135249.png" alt="$t\in[-10,10]$">.</p>
<p>
<b>6.</b> Construir una app que permita:</p>
<div>
<ul>
<li>Gr&aacute;ficar se&ntilde;ales en tiempo continuo reales, el usuario ingresa la definici&oacute;n de la se&ntilde;al en el formato especifico.</li>
<li>El usuario puede definir el intervalo de la gr&aacute;fica.</li>
<li>El usuario puede seleccionar el tipo de transformaci&oacute;n (horizontal, vertical o combinaci&oacute;n) que desee realizar a la se&ntilde;al, la app deber&aacute; mostrar la gr&aacute;fica de esta transformaci&oacute;n.</li>
<li>Se adjunta una imagen de la app a la pr&aacute;ctica, y el archivo de la app.</li>
</ul>
</div>
<p>No es necesario incluir conclusiones en esta pr&aacute;ctica, si lo considera necesario puede incluir ap&eacute;ndices, no olvide incluir sus referencias.</p>
<h2 id="5">Problema 1</h2>
<p>Reproducir la secci&oacute;n 1.11 del libro de Lathi (versi&oacute;n de clase). La versi&oacute;n utilizada en clase es la tercera edici&oacute;n.</p>
<p>1.11 MATLAB: Trabajando con funciones</p>
<p>Trabajar con funciones es fundamental para las aplicaciones de se&ntilde;ales y sistemas. MATLAB proporciona varios m&eacute;todos para definir y evaluar funciones. La comprensi&oacute;n y el uso competente de estos m&eacute;todos son, por tanto, necesarios y beneficiosos.</p>
<p>1.11-1 Funciones an&oacute;nimas</p>
<p>Muchas funciones simples se representan convenientemente mediante el uso an&oacute;nimo de MATLAB. Una funci&oacute;n an&oacute;nima proporciona una representaci&oacute;n simb&oacute;lica de una funci&oacute;n definida en t&eacute;rminos de operadores, funciones u otras funciones an&oacute;nimas de MATLAB. Por ejemplo, considere definir la sinusoide amortiguada exponencialmente <img src="PR03_eq17807686604900783746.png" alt="$f(t) = e^{-t} cos(2\pi  t)$">.</p>
<pre class="codeinput">f = @(t) exp(-t).*cos(2*pi*t);
</pre>
<p>En este contexto, el s&iacute;mbolo @ identifica la expresi&oacute;n como una funci&oacute;n an&oacute;nima, que se asigna un nombre de f. Los par&eacute;ntesis que siguen al s&iacute;mbolo @ se utilizan para identificar la funci&oacute;n independiente. variables (argumentos de entrada), que en este caso es la &uacute;nica variable de tiempo t. Argumentos de entrada, como como t, son locales de la funci&oacute;n an&oacute;nima y no est&aacute;n relacionados con ninguna variable del espacio de trabajo con la mismos nombres.</p>
<p>Una vez definida, f (t) se puede evaluar simplemente pasando los valores de entrada de inter&eacute;s. Por ejemplo:</p>
<pre class="codeinput">t = 0; f(t)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>eval&uacute;a f(t) en t = 0, confirmando el resultado esperado de la unidad. El mismo resultado se obtiene pasando t = 0 directamente.</p>
<pre class="codeinput">f(0)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>Las entradas vectoriales permiten la evaluaci&oacute;n de m&uacute;ltiples valores simult&aacute;neamente. Considere la tarea de trazar f(t) en el intervalo <img src="PR03_eq18236345434950197352.png" alt="$(-2 <= t <= 2)$">. El comportamiento de la funci&oacute;n bruta es claro: f(t) deber&iacute;a oscilar cuatro veces con una envolvente en decayente. Dado que los bocetos precisos a mano son engorrosos, los gr&aacute;ficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, se deben tomar medidas para garantizar resultados confiables. Supongamos que se elige el vector t para incluir solo los n&uacute;meros enteros contenidos en <img src="PR03_eq18236345434950197352.png" alt="$(-2 <= t <= 2)$">, es decir, <img src="PR03_eq00323666827583285953.png" alt="$[-2,-1, 0, 1,2]$">.</p>
<pre class="codeinput">t = (-2:2);
</pre>
<p>Esta entrada vectorial se eval&uacute;a para formar una salida vectorial.</p>
<pre class="codeinput">f(t)
</pre>
<pre class="codeoutput">
ans =

    7.3891    2.7183    1.0000    0.3679    0.1353

</pre>
<p>El comando de trazado grafica el resultado, que se muestra:</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'f(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="PR03_01.png" alt=""> <p>Las l&iacute;neas de cuadr&iacute;cula, agregadas mediante el comando de cuadr&iacute;cula, ayudan a identificar las caracter&iacute;sticas. Desafortunadamente, el gr&aacute;fico no ilustra el comportamiento oscilatorio esperado. Se requieren m&aacute;s puntos para adecuadamente representar f(t).</p>
<p>La pregunta entonces es &iquest;cu&aacute;ntos puntos son suficientes? Si se eligen muy pocos puntos, la informaci&oacute;n est&aacute; perdida. Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio. Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilaci&oacute;n. Para el presente en este caso, se elige t para dar 100 puntos por oscilaci&oacute;n.</p>
<pre class="codeinput">t = (-2:0.01:2);
</pre>
<p>La funci&oacute;n es de nuevo evaluada y graficada:</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'f(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="PR03_02.png" alt=""> <p>1.11-2 Operadores relacionales y la funci&oacute;n de paso unitario</p>
<p>La funci&oacute;n escal&oacute;n unitario u(t) surge naturalmente en muchas situaciones pr&aacute;cticas. Por ejemplo, un escal&oacute;n unitario puede modelar el acto de encender un sistema. Con la ayuda de operadores relacionales, funciones an&oacute;nimas puede representar la funci&oacute;n de escal&oacute;n unitario.</p>
<p>En MATLAB, un operador relacional compara dos elementos. Si la comparaci&oacute;n es cierta, una verdad l&oacute;gica (1) se devuelve. Si la comparaci&oacute;n es falsa, se devuelve un falso l&oacute;gico (0). A veces llamado indicador de funciones, los operadores relacionales indican si una condici&oacute;n es verdadera. Seis operadores relacionales disponibles: &lt;, &gt;, &lt;=, &gt;=, ==, y ~=.</p>
<p>La funci&oacute;n de escal&oacute;n unitario se define f&aacute;cilmente utilizando el operador relacional &gt;=.</p>
<pre class="codeinput">u = @(t) 1.0.*(t&gt;=0);
</pre>
<p>Cualquier funci&oacute;n con una discontinuidad de salto, como el escal&oacute;n unitario, es dif&iacute;cil de trazar. Considere la posibilidad de trazar u(t) usando t = (-2:2).</p>
<pre class="codeinput">t = (-2:2); plot(t,u(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'u(t)'</span>);
</pre>
<img vspace="5" hspace="5" src="PR03_03.png" alt=""> <p>Dos problemas importantes son evidentes en el gr&aacute;fico resultante, que se muestra. Primero, MATLAB escala autom&aacute;ticamente los ejes del gr&aacute;fico para vincular estrechamente los datos. Normalmente, en este caso, la caracter&iacute;stica deseable oscurece la mayor parte de la trama. En segundo lugar, MATLAB conecta los datos del trazado con l&iacute;neas, haciendo que una verdadera discontinuidad de salto sea dif&iacute;cil de lograr. La resoluci&oacute;n gruesa del vector t enfatiza el efecto al mostrar una l&iacute;nea inclinada err&oacute;nea entre t=&minus;1 y t = 0. El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje dominio. El segundo problema se reduce, pero no se elimina, sumando puntos al vector t.</p>
<pre class="codeinput">t = (-2:0.01:2); plot(t,u(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'u(t)'</span>);
axis([-2 2 -0.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="PR03_04.png" alt=""> <p>El argumento vectorial de cuatro elementos del eje especifica el eje x m&iacute;nimo, el eje x m&aacute;ximo, el eje y m&iacute;nimo y el m&aacute;ximo del eje y, respectivamente. Como se puede obserbar en la gr&aacute;fica anterior.</p>
<p>Los operadores relacionales se pueden combinar usando AND l&oacute;gico, O l&oacute;gico y negaci&oacute;n l&oacute;gica: &amp;, | y ~, respectivamente. Por ejemplo, (t&gt;0)&amp;(t&lt;1) y ~((t&lt;=0)|(t&gt;=1)) prueban si 0&lt;t &lt;1. Para demostrarlo, considere definir y trazar el pulso unitario p(t)=u(t)&minus;u(t&minus;1), como se muestra:</p>
<pre class="codeinput">p = @(t) 1.0.*((t&gt;=0)&amp;(t&lt;1));
t = (-1:0.01:2); plot(t,p(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'p(t) = u(t)-u(t-1)'</span>);
axis([-1 2 -.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="PR03_05.png" alt=""> <p>Para operandos escalares, MATLAB tambi&eacute;n admite dos construcciones l&oacute;gicas de cortocircuito. El AND l&oacute;gico de cortocircuito se realiza mediante &amp;&amp;, y el OR l&oacute;gico de cortocircuito se realiza usando. Los operadores l&oacute;gicos de cortocircuito suelen ser m&aacute;s eficientes que los operadores l&oacute;gicos tradicionales porque prueban la segunda parte de la expresi&oacute;n s&oacute;lo cuando es necesario. Es decir, cuandouna expresi&oacute;n escalar A se encuentra falsa en (A&amp;&amp;B), la expresi&oacute;n escalar B no se eval&uacute;a, ya que un resultado falso ya est&aacute; garantizado. De manera similar, la expresi&oacute;n escalar B no se eval&uacute;a cuando la expresi&oacute;n escalar A es encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.</p>
<p>1.11-3 Visualizaci&oacute;n de operaciones en la variable independiente</p>
<p>Com&uacute;nmente se encuentran dos operaciones sobre la variable independiente de una funci&oacute;n: desplazamiento y escalada. Las funciones an&oacute;nimas son muy adecuadas para investigar ambas operaciones. Considere g(t) = f (t)u(t) = e&minus;t cos (2πt)u(t), una versi&oacute;n causal de f (t). MATLAB f&aacute;cilmente multiplica funciones an&oacute;nimas. Por lo tanto, creamos g(t) multiplicando nuestras funciones an&oacute;nimas para f (t) y u(t).</p>
<pre class="codeinput">g = @(t) f(t).*u(t);
</pre>
<p>Una operaci&oacute;n combinada de desplazamiento y escalamiento est&aacute; representada por g(at + b), donde a y b son constantes reales arbitrarias. Como ejemplo, considere graficar g(2t+1) sobre (&minus;2 &le; t &le; 2). Con a = 2, la funci&oacute;n se comprime por un factor de 2, lo que da como resultado el doble de oscilaciones por unidad t. A&ntilde;adiendo la condici&oacute;n b &gt; 0 desplaza la forma de onda hacia la izquierda. Dada la funci&oacute;n an&oacute;nima g, una gr&aacute;fica precisa es casi trivial de obtener.</p>
<pre class="codeinput">t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(2t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="PR03_06.png" alt=""> <p>Confirma la compresi&oacute;n esperada de la forma de onda y el desplazamiento hacia la izquierda. Como comprobaci&oacute;n final, tenga en cuenta esa funci&oacute;n g(&middot;) se activa cuando el argumento de entrada es cero. Por lo tanto, g(2t +1) deber&iacute;a activarse cuando 2t+1 = 0 o en t=&minus;0.5, un hecho nuevamente confirmado,</p>
<p>Considere trazar g(&minus;t + 1) sobre (&minus;2 &le; t &le; 2). Como a &lt; 0, la forma de onda ser&aacute; reflejada. Agregar la condici&oacute;n b &gt; 0 desplaza la forma de onda final hacia la derecha.</p>
<pre class="codeinput">plot(t,g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(-t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="PR03_07.png" alt=""> <p>Hasta este punto, las gr&aacute;ficas anteriores pueden ser graficadas razonablemente a mano. Considere la posibilidad de trazar la funci&oacute;n m&aacute;s complicada h(t) = g(2t + 1) + g(&minus;t + 1) sobre (&minus;2 &le; t &le; 2) un boceto a mano preciso ser&iacute;a bastante dif&iacute;cil. Con MATLAB, el trabajo es mucho menos pesado.</p>
<pre class="codeinput">plot(t,g(2*t+1)+g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'h(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="PR03_08.png" alt=""> <p>1.11-4 Integraci&oacute;n num&eacute;rica y estimaci&oacute;n de la energ&iacute;a de la se&ntilde;al</p>
<p>Las se&ntilde;ales interesantes suelen tener representaciones matem&aacute;ticas no triviales. Computar la energ&iacute;a de la se&ntilde;al, que implica integrar el cuadrado de estas expresiones, puede ser una tarea desalentadora. Afortunadamente, muchas integrales dif&iacute;ciles se pueden estimar con precisi&oacute;n mediante t&eacute;cnicas de integraci&oacute;n num&eacute;rica.</p>
<p>Incluso si la integraci&oacute;n parece simple, la integraci&oacute;n num&eacute;rica proporciona una buena manera de verificar resultados anal&iacute;ticos.</p>
<p>Para empezar, considere la se&ntilde;al simple <img src="PR03_eq12615705837752770589.png" alt="$x(t) = e^{-t} (u(t)-u(t-1))$">. La energ&iacute;a de x(t) se expresa como <img src="PR03_eq02923008350305632635.png" alt="$Ex = \int_{-\infty}^{\infty} |x(t)|^2 dt = \int_{0}^{1} e^{-2t}dt$">. Integrando rendimientos <img src="PR03_eq05025388734129832857.png" alt="$Ex = 0.5(1-e^{-2}) = 0.4323$">. La energ&iacute;a integral tambi&eacute;n se puede evaluar num&eacute;ricamente. Evaluar el integrando en puntos uniformemente separados por t, multiplicar cada uno por t para calcular las &aacute;reas del rect&aacute;ngulo y luego sumar todos los rect&aacute;ngulos. Primero, creamos la funci&oacute;n x(t).</p>
<pre class="codeinput">x = @(t) exp(-t).*((t&gt;=0)&amp;(t&lt;1));
</pre>
<p>Con t = 0,01 se crea un vector de tiempo adecuado.</p>
<pre class="codeinput">t=(0:0.01:1);
</pre>
<p>El resultado final es computado usango el comando sum:</p>
<pre class="codeinput">E_x = sum(x(t).*x(t)*0.01)
</pre>
<pre class="codeoutput">
E_x =

    0.4367

</pre>
<p>El resultado no es perfecto, pero con un error relativo del 1% est&aacute; cerca. Reduciendo t, la aproximaci&oacute;n mejora. Por ejemplo, t = 0,001 produce E_x = 0,4328, o un error relativo del 0,1%.</p>
<p>Aunque es f&aacute;cil de visualizar, la aproximaci&oacute;n rectangular no es la mejor t&eacute;cnica de integraci&oacute;n num&eacute;rica. La funci&oacute;n quad de MATLAB implementa una mejor t&eacute;cnica de integraci&oacute;n num&eacute;rica llamada cuadratura de Simpson adaptativa recursiva. Para operar, quad requiere una funci&oacute;n que describa el integrando, el l&iacute;mite inferior de integraci&oacute;n y el l&iacute;mite superior de integraci&oacute;n. Observe que no es necesario especificar.</p>
<p>Para utilizar quad para estimar Ex, primero se debe describir el integrando.</p>
<pre class="codeinput">x_squared = @(t) x(t).*x(t);
</pre>
<p>Estimando Ex, le sigue:</p>
<pre class="codeinput">E_x = quad(x_squared,0,1)
</pre>
<pre class="codeoutput">
E_x =

    0.4323

</pre>
<p>En este caso el error relativo es de -0.0026%. Se pueden utilizar las mismas t&eacute;cnicas para estimar la energ&iacute;a de se&ntilde;ales m&aacute;s complejas. Considerar g(t), definido previamente. La energ&iacute;a est&aacute; expresada como <img src="PR03_eq03864113705538071334.png" alt="$Eg = \int_{0}^{\infty} e^{-2t}cos^2(2 \pi t) dt$">. Una soluci&oacute;n de forma cerrada existe, pero requiere algo de esfuerzo. MATLAB proporciona una respuesta m&aacute;s r&aacute;pidamente.</p>
<pre class="codeinput">g_squared = @(t) g(t).*g(t);
</pre>
<p>Aunque el l&iacute;mite superior de integraci&oacute;n es infinito, la envolvente que decae exponencialmente asegura g(t) es efectivamente cero mucho antes de t = 100. Por lo tanto, se utiliza un l&iacute;mite superior de t = 100 junto con t = 0,001.</p>
<pre class="codeinput">t = (0:0.001:100);
E_g = sum(g_squared(t)*0.001)
</pre>
<pre class="codeoutput">
E_g =

    0.2567

</pre>
<p>Se obtiene una aproximaci&oacute;n ligeramente mejor con la funci&oacute;n quad.</p>
<pre class="codeinput">E_g = quad(g_squared,0,100)
</pre>
<pre class="codeoutput">
E_g =

    0.2562

</pre>
<p>EJERCICIO 1.21 C&aacute;lculo de la energ&iacute;a de la se&ntilde;al con MATLAB</p>
<p>Utilice MATLAB para confirmar que la energ&iacute;a de la se&ntilde;al h(t), definida previamente como h(t) = g(2t+1)+g(&minus;t+1), es Eh = 0.3768.</p>
<pre class="codeinput">h = @(t) g(2*t+1)+g(-t+1);
h_squared = @(t) h(t).*h(t);
E_h = quad(h_squared,-100,100)
</pre>
<pre class="codeoutput">
E_h =

    0.3768

</pre>
<h2 id="30">Problema 2</h2>
<p>Resolver el problema 1.2-2 usando las herramientas del problema anterior.</p>
<p>1.2-2 Para la se&ntilde;al <img src="PR03_eq12659395712222829305.png" alt="$x(t)$"> mostrada a continuaci&oacute;n, graficar:</p>
<p>
<b>(a)</b> <img src="PR03_eq01500215214527907328.png" alt="$x(t-4)$"></p>
<p>
<b>(b)</b> <img src="PR03_eq04159074189963937569.png" alt="$x(t/1.5)$"></p>
<p>
<b>(c)</b> <img src="PR03_eq03478510484075753106.png" alt="$x(-t)$"></p>
<p>
<b>(d)</b> <img src="PR03_eq06043308101618656396.png" alt="$x(2t-4)$"></p>
<p>
<b>(e)</b> <img src="PR03_eq00276141918373872221.png" alt="$x(2-t)$"></p>
<p>
<img vspace="5" hspace="5" src="P1.2-2.png" alt=""> </p>
<p>Tenemos que la funci&oacute;n x(t) = -t.*(u(t+4)-u(t)) + t.*(u(t)-u(t-2))</p>
<pre class="codeinput">t = (-10:0.01:10);
x = @(t) -t.*(u(t+4)-u(t)) + t.*(u(t)-u(t-2));
plot(t,x(t)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="PR03_09.png" alt=""> <p>Vamos a graficar las 5 gr&aacute;ficas solicitadas en un subploat de 3x2 con su identificador correspondiente a cada gr&aacute;fica:</p>
<pre class="codeinput">figure()
subplot(3,2,1)
plot(t,x(t-4),<span class="string">'LineWidth'</span>,2); title(<span class="string">'(a)'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t-4)'</span>); grid; axis([-5 7,0,5])
subplot(3,2,2)
plot(t,x(t/1.5),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2); title(<span class="string">'(b)'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t/1.5)'</span>); grid; axis([-7 5,0,5])
subplot(3,2,3)
plot(t,x(-t),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,2); title(<span class="string">'(c)'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(-t)'</span>); grid; axis([-6 6,0,5])
subplot(3,2,4)
plot(t,x(t.*2-4),<span class="string">'m'</span>,<span class="string">'LineWidth'</span>,2); title(<span class="string">'(d)'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(2t-4)'</span>); grid; axis([-6 6,0,5])
subplot(3,2,5)
plot(t,x(2-t),<span class="string">'c'</span>,<span class="string">'LineWidth'</span>,2); title(<span class="string">'(e)'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(2-t)'</span>); grid; axis([-5 7,0,5])
</pre>
<img vspace="5" hspace="5" src="PR03_10.png" alt=""> <h2 id="32">Problema 3</h2>
<p>Resolver el problema 1.11-1, los ejes deben mostrarse en el origen adem&aacute;s de la edici&oacute;n de tu preferencia.</p>
<p>1.11-1 Proporcionar el c&oacute;digo de MATLAB y los resultados que tracen la porci&oacute;n impar Xo(t) de la funci&oacute;n <img src="PR03_eq14714011988538647792.png" alt="$x(t) = 2^{-t} cos(2 \pi t) u(t - \pi)$"> en un intervalo de longitud adecuada utilizando un n&uacute;mero adecuado de puntos.</p>
<p>Tenemos que <img src="PR03_eq14714011988538647792.png" alt="$x(t) = 2^{-t} cos(2 \pi t) u(t - \pi)$"></p>
<pre class="codeinput">figure()
x = @(t) (2.^(-t)).*cos(2.*pi.*t).*u(t-pi);
t = (-10:0.01:10);
plot(t,x(t),<span class="string">'LineWidth'</span>,1); title(<span class="string">'Problema 1.11-1'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t)'</span>); grid; axis([2 10,-0.09,0.09])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;
</pre>
<img vspace="5" hspace="5" src="PR03_11.png" alt=""> <p>Ahora se graficar&aacute; la parte impar de la se&ntilde;al</p>
<pre class="codeinput">figure()
Xo = @(t) (x(t) - x(-t))/2;
plot(t,Xo(t),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,1); title(<span class="string">'Problema 1.11-1 parte impar'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'Xo(t)'</span>); grid; axis([-10 10,-0.05,0.05])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;
</pre>
<img vspace="5" hspace="5" src="PR03_12.png" alt=""> <h2 id="34">Problema 4</h2>
<p>Construye la gr&aacute;fica de: <img src="PR03_eq01254418086591493464.png" alt="$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$"> para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen ademas de la edici&oacute;n de su preferencia.</p>
<pre class="codeinput">x = @(t) cos(2.*pi.*1.*t) + cos(2.*pi.*2.*t) + cos(2.*pi.*3.*t) + cos(2.*pi.*4.*t) + cos(2.*pi.*5.*t) + cos(2.*pi.*6.*t) + cos(2.*pi.*7.*t) + cos(2.*pi.*8.*t) + cos(2.*pi.*9.*t) + cos(2.*pi.*10.*t);
figure()
subplot(2,2,1)
plot(t,x(t),<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Funci&oacute;n x(t) de -3 a 3'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t)'</span>); grid; axis([-3 3,-3,10])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;

subplot(2,2,2)
plot(t,x(t),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Funci&oacute;n x(t) de 0 a 1'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t)'</span>); grid; axis([0 1,-3,10])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;

subplot(2,2,3)
plot(t,x(t),<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Funci&oacute;n x(t) de 2 a 5'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t)'</span>); grid; axis([2 5,-3,10])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;

subplot(2,2,4)
plot(t,x(t),<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Funci&oacute;n x(t) de -1 a 1'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t)'</span>); grid; axis([-1 1,-3,10])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;
</pre>
<img vspace="5" hspace="5" src="PR03_13.png" alt=""> <h2 id="35">Problema 5</h2>
<p>Resolver el problema 1.11-3, agregar como inciso (e) la gr&aacute;fica de <img src="PR03_eq12659395712222829305.png" alt="$x(t)$"> para <img src="PR03_eq16434444273656135249.png" alt="$t\in[-10,10]$">.</p>
<p>1.11-3 Define <img src="PR03_eq17392014776415934218.png" alt="$x(t) = e^{t(1+j2\pi)}u(-t)$"> y <img src="PR03_eq11108666508949447005.png" alt="$y(t) = Re\{2x(\frac{-5-t} 2 \}$"></p>
<p>
<b>(a)</b> Utilice MATLAB para graficar <img src="PR03_eq12322047428404766036.png" alt="$Re \{ x(t) \}$"> con respecto <img src="PR03_eq16187411168842112666.png" alt="$Im \{ x(at) \}$"> para <img src="PR03_eq16256654715526823454.png" alt="$a = 0.5, 1, 2$"> y <img src="PR03_eq14634900462739659407.png" alt="$-10 <= t <=10$"> &iquest;Qu&eacute; importante es el factor escalar <img src="PR03_eq04574278970515790912.png" alt="$a$"> en la forma de la figura resultante?</p>
<p>
<b>(b)</b> Utilice MATLAB para graficar <img src="PR03_eq17784377804790973832.png" alt="$y(t)$"> sobre <img src="PR03_eq14634900462739659407.png" alt="$-10 <= t <=10$"> Determine anal&iacute;ticamente el tiempo <img src="PR03_eq06345596366822266005.png" alt="$t_0$"> donde y(t) tiene una discontinuidad de salto. Verifique su c&aacute;lculo de <img src="PR03_eq06345596366822266005.png" alt="$t_0$"> utilizando la gr&aacute;fica de y(t).</p>
<p>
<b>(c)</b> Utilice MATLAB y la integraci&oacute;n num&eacute;rica para calcular la energ&iacute;a <img src="PR03_eq05569007377996954769.png" alt="$E_x$"> de la se&ntilde;al <img src="PR03_eq12659395712222829305.png" alt="$x(t)$">.</p>
<p>
<b>(d)</b> Utilice MATLAB y la integraci&oacute;n num&eacute;rica para calcular la energ&iacute;a <img src="PR03_eq00014393055024678951.png" alt="$E_y$"> de la se&ntilde;al <img src="PR03_eq17784377804790973832.png" alt="$y(t)$">.</p>
<p>
<b>(e)</b> Graficar <img src="PR03_eq12659395712222829305.png" alt="$x(t)$"> para <img src="PR03_eq16434444273656135249.png" alt="$t\in[-10,10]$">.</p>
<p>
<b>(a)</b>
</p>
<pre class="codeinput">t=(-10:0.01:10);
a = [0.5, 1, 2];
x = @(t) exp(t.*(1+(2*pi*1j))).*u(-t);
y = @(t) real(2*x((-5-t)/2));
xr = real(x(t));
xi = imag (x(a(1)*t));

figure()
plot(xi,xr,<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Inciso (a) con a = 0.5'</span>); xlabel(<span class="string">'Im\{x(at)\}'</span>); ylabel(<span class="string">'Re\{x(t)\}'</span>); grid; axis([-1 1,-1.1,1.1])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;

figure()
xi = imag (x(a(2)*t));
plot(xi,xr,<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Inciso (a) con a = 1'</span>); xlabel(<span class="string">'Im\{x(at)\}'</span>); ylabel(<span class="string">'Re\{x(t)\}'</span>); grid; axis([-1 1,-1.1,1.1])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;

figure()
xi = imag (x(a(3)*t));
plot(xi,xr,<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Inciso (a) con a = 2'</span>); xlabel(<span class="string">'Im\{x(at)\}'</span>); ylabel(<span class="string">'Re\{x(t)\}'</span>); grid; axis([-1 1,-1.1,1.1])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;
</pre>
<img vspace="5" hspace="5" src="PR03_14.png" alt=""> <img vspace="5" hspace="5" src="PR03_15.png" alt=""> <img vspace="5" hspace="5" src="PR03_16.png" alt=""> <p>
<b>(b)</b>
</p>
<pre class="codeinput">figure()
t = (-10:0.01:10);
plot(t,y(t),<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Inciso (b)'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(t)'</span>); grid; axis([-10 10,-2.5,2.5])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;
</pre>
<img vspace="5" hspace="5" src="PR03_17.png" alt=""> <p>Comprobando analiticamente la discontinuidad <img src="PR03_eq06345596366822266005.png" alt="$t_0$"> si <img src="PR03_eq11108666508949447005.png" alt="$y(t) = Re\{2x(\frac{-5-t} 2 \}$"></p>
<pre class="codeinput">dis = find(diff(y(t)));
t0 = t(dis(1))
</pre>
<pre class="codeoutput">
t0 =

   -5.0100

</pre>
<p>
<b>(c)</b>
</p>
<pre class="codeinput">fun = @(t) abs(x(t)).^2;
Ex = integral(fun,-Inf,Inf)
</pre>
<pre class="codeoutput">
Ex =

    0.5000

</pre>
<p>
<b>(d)</b>
</p>
<pre class="codeinput">fun2 = @(t) abs(y(t)).^2;
Ey = integral(fun2,-Inf,Inf)
</pre>
<pre class="codeoutput">
Ey =

    2.0494

</pre>
<p>
<b>(e)</b>
</p>
<pre class="codeinput">figure()
t = (-10:0.01:10);
plot(t,x(t),<span class="string">'LineWidth'</span>,0.3); title(<span class="string">'Inciso (e)'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x(t)'</span>); grid; axis([-10 10,-1.1,1.1])
ax = gca;
ax.XAxisLocation = <span class="string">'origin'</span>;
ax.YAxisLocation = <span class="string">'origin'</span>;
ax.Box = <span class="string">'off'</span>;
</pre>
<pre class="codeoutput">Warning: Imaginary parts of complex X and/or Y arguments ignored. 
</pre>
<img vspace="5" hspace="5" src="PR03_18.png" alt=""> <h2 id="41">Problema 6</h2>
<p>Construir una app que permita:</p>
<div>
<ul>
<li>Gr&aacute;ficar se&ntilde;ales en tiempo continuo reales, el usuario ingresa la definici&oacute;n de la se&ntilde;al en el formato especifico.</li>
<li>El usuario puede definir el intervalo de la gr&aacute;fica.</li>
<li>El usuario puede seleccionar el tipo de transformaci&oacute;n (horizontal, vertical o combinaci&oacute;n) que desee realizar a la se&ntilde;al, la app deber&aacute; mostrar la gr&aacute;fica de esta transformaci&oacute;n.</li>
<li>Se adjunta una imagen de la app a la pr&aacute;ctica, y el archivo de la app.</li>
</ul>
</div>
<p>
<img vspace="5" hspace="5" src="app.png" alt=""> </p>
<pre class="codeinput">
<span class="comment">%</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Práctica 3: Señales en tiempo continuo
%
%
%% Integrantes
%
% Portillo Martínez Arturo
%
%% Objetivos
%
% * Manipulación básica de MATLAB.
% * Gráficas de señales reales y complejas continuas.
% * Transformación de señales continuas (escalamientos y traslaciones).
% * Clculo de energía y potencia de señales continuas.
%
%% Introducción
%
% Se realizó la investigación del uso de Python para la realización de
% gráficas, a continuación se muestran las gráficas correspondientes al problema 4 mediante Python.
% 
% <<intro.png>>
%
% Se puede consultar el código realizado con Python en el siguiente <https://colab.research.google.com/drive/1XnKYDQmnbECtDmMwu0-lw2WxHoELL3KE?usp=sharing enlace>. 
%
%% Desarrollo
%
% A continuación se realizará el desarrollo de los siguientes problemas
% planteados para entregar en la práctica.
% 
% *1.* Reproducir la sección 1.11 del libro de Lathi (versión de clase).
%
% *2.* Resolver el problema 1.2-2 usando las herramientas del problema
% anterior.
% *3.* Resolver el problema 1.11-1, los ejes deben mostrarse en el origen
% además de la edición de tu preferencia.
%
% *4.* Construye la gráfica de: $$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$  para cuatro rangos (figura 2x2).
% Los ejes deben mostrarse en el origen ademas de la edición de su preferencia.
%
% *5.* Resolver el problema 1.11-3, agregar como inciso (e) la gráfica de
% $x(t)$ para $t\in[-10,10]$.
%
% *6.* Construir una app que permita:
%
% * Gráficar señales en tiempo continuo reales, el usuario ingresa la
% definición de la señal en el formato especifico.
% * El usuario puede definir el intervalo de la gráfica.
% * El usuario puede seleccionar el tipo de transformación (horizontal,
% vertical o combinación) que desee realizar a la señal, la app deberá
% mostrar la gráfica de esta transformación.
% * Se adjunta una imagen de la app a la práctica, y el archivo de la app.
%
% No es necesario incluir conclusiones en esta práctica, si lo considera
% necesario puede incluir apéndices, no olvide incluir sus referencias.
%
%% Problema 1
%
% Reproducir la sección 1.11 del libro de Lathi (versión de clase).
% La versión utilizada en clase es la tercera edición.
% 
% 1.11 MATLAB: Trabajando con funciones
%
% Trabajar con funciones es fundamental para las aplicaciones de señales y sistemas. MATLAB proporciona varios métodos para definir y evaluar funciones. La comprensión y el uso competente de estos métodos son, por tanto, necesarios y beneficiosos.
%
%
% 1.11-1 Funciones anónimas
%
% Muchas funciones simples se representan convenientemente mediante el uso anónimo de MATLAB.
% Una función anónima proporciona una representación simbólica de una función definida en términos de operadores, funciones u otras funciones anónimas de MATLAB. 
% Por ejemplo, considere definir la sinusoide amortiguada exponencialmente
% $$f(t) = e^{-t} cos(2\pi  t)$$.
f = @(t) exp(-t).*cos(2*pi*t);

%% 
% En este contexto, el símbolo @ identifica la expresión como una función anónima, que se asigna
% un nombre de f. Los paréntesis que siguen al símbolo @ se utilizan para identificar la función independiente.
% variables (argumentos de entrada), que en este caso es la única variable de tiempo t. Argumentos de entrada, como
% como t, son locales de la función anónima y no están relacionados con ninguna variable del espacio de trabajo con la
% mismos nombres.
%
% Una vez definida, f (t) se puede evaluar simplemente pasando los valores
% de entrada de interés. Por ejemplo:
t = 0; f(t)

%%
% evalúa f(t) en t = 0, confirmando el resultado esperado de la unidad. El mismo resultado se obtiene pasando t = 0 directamente.
f(0)

%%
% Las entradas vectoriales permiten la evaluación de múltiples valores simultáneamente.
% Considere la tarea de trazar f(t) en el intervalo $$(-2 <= t <= 2)$$.
% El comportamiento de la función bruta es claro: f(t) debería oscilar cuatro veces con una envolvente en decayente.
% Dado que los bocetos precisos a mano son engorrosos, los gráficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, se deben tomar medidas para garantizar resultados confiables.
% Supongamos que se elige el vector t para incluir solo los números enteros contenidos en $$(-2 <= t <= 2)$$, es decir, $$[-2,-1, 0, 1,2]$$.
t = (-2:2);

%%
% Esta entrada vectorial se evalúa para formar una salida vectorial.
f(t)

%%
% El comando de trazado grafica el resultado, que se muestra:
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;

%%
% Las líneas de cuadrícula, agregadas mediante el comando de cuadrícula, ayudan a identificar las características. 
% Desafortunadamente, el gráfico no ilustra el comportamiento oscilatorio esperado. 
% Se requieren más puntos para adecuadamente representar f(t).
%
% La pregunta entonces es ¿cuántos puntos son suficientes? Si se eligen muy pocos puntos, la información está perdida. 
% Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio. 
% Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilación. 
% Para el presente en este caso, se elige t para dar 100 puntos por oscilación.
t = (-2:0.01:2);

%%
% La función es de nuevo evaluada y graficada:
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;

%%
% 1.11-2 Operadores relacionales y la función de paso unitario
% 
% La función escalón unitario u(t) surge naturalmente en muchas situaciones prácticas. 
% Por ejemplo, un escalón unitario puede modelar el acto de encender un sistema. 
% Con la ayuda de operadores relacionales, funciones anónimas puede representar la función de escalón unitario.
%
% En MATLAB, un operador relacional compara dos elementos. 
% Si la comparación es cierta, una verdad lógica (1) se devuelve. 
% Si la comparación es falsa, se devuelve un falso lógico (0). 
% A veces llamado indicador de funciones, los operadores relacionales indican si una condición es verdadera. 
% Seis operadores relacionales disponibles: <, >, <=, >=, ==, y ~=.
%
% La función de escalón unitario se define fácilmente utilizando el operador relacional >=.
u = @(t) 1.0.*(t>=0);

%%
% Cualquier función con una discontinuidad de salto, como el escalón unitario, es difícil de trazar. 
% Considere la posibilidad de trazar u(t) usando t = (-2:2).
t = (-2:2); plot(t,u(t));
xlabel('t'); ylabel('u(t)');

%%
% Dos problemas importantes son evidentes en el gráfico resultante, que se
% muestra. Primero, MATLAB escala automáticamente los ejes del gráfico para vincular estrechamente los datos. 
% Normalmente, en este caso, la característica deseable oscurece la mayor parte de la trama. 
% En segundo lugar, MATLAB conecta los datos del trazado con líneas, haciendo que una verdadera discontinuidad de salto sea difícil de lograr.
% La resolución gruesa del vector t enfatiza el efecto al mostrar una línea inclinada errónea entre t=−1 y t = 0.
% El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje dominio. 
% El segundo problema se reduce, pero no se elimina, sumando puntos al vector t.
t = (-2:0.01:2); plot(t,u(t));
xlabel('t'); ylabel('u(t)');
axis([-2 2 -0.1 1.1]);

%%
% El argumento vectorial de cuatro elementos del eje especifica el eje x mínimo, el eje x máximo, el eje y mínimo y el máximo del eje y, respectivamente. 
% Como se puede obserbar en la gráfica anterior.
%
% Los operadores relacionales se pueden combinar usando AND lógico, O lógico y negación lógica: &, | y ~, respectivamente. 
% Por ejemplo, (t>0)&(t<1) y ~((t<=0)|(t>=1)) prueban si 0<t <1.
% Para demostrarlo, considere definir y trazar el pulso unitario p(t)=u(t)−u(t−1), como se muestra:
p = @(t) 1.0.*((t>=0)&(t<1));
t = (-1:0.01:2); plot(t,p(t));
xlabel('t'); ylabel('p(t) = u(t)-u(t-1)');
axis([-1 2 -.1 1.1]);

%%
% Para operandos escalares, MATLAB también admite dos construcciones lógicas de cortocircuito.
% El AND lógico de cortocircuito se realiza mediante &&, y el OR lógico de cortocircuito se realiza usando ||. 
% Los operadores lógicos de cortocircuito suelen ser más eficientes que los operadores lógicos tradicionales porque prueban la segunda parte de la expresión sólo cuando es necesario. 
% Es decir, cuandouna expresión escalar A se encuentra falsa en (A&&B), la expresión escalar B no se evalúa, ya que un resultado falso ya está garantizado. 
% De manera similar, la expresión escalar B no se evalúa cuando la expresión escalar A es encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.
%
% 1.11-3 Visualización de operaciones en la variable independiente
%
% Comúnmente se encuentran dos operaciones sobre la variable independiente de una función: desplazamiento y escalada. 
% Las funciones anónimas son muy adecuadas para investigar ambas operaciones.
% Considere g(t) = f (t)u(t) = e−t cos (2πt)u(t), una versión causal de f (t). 
% MATLAB fácilmente multiplica funciones anónimas. 
% Por lo tanto, creamos g(t) multiplicando nuestras funciones anónimas para f (t) y u(t).
g = @(t) f(t).*u(t);

%%
% Una operación combinada de desplazamiento y escalamiento está representada por g(at + b), donde a y b son constantes reales arbitrarias. 
% Como ejemplo, considere graficar g(2t+1) sobre (−2 ≤ t ≤ 2). Con a = 2, la función se comprime por un factor de 2, lo que da como resultado el doble de oscilaciones por unidad t. 
% Añadiendo la condición b > 0 desplaza la forma de onda hacia la izquierda. 
% Dada la función anónima g, una gráfica precisa es casi trivial de obtener.
t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel('t'); ylabel('g(2t+1)'); grid;

%%
% Confirma la compresión esperada de la forma de onda y el desplazamiento hacia la izquierda. 
% Como comprobación final, tenga en cuenta esa función g(·) se activa cuando el argumento de entrada es cero. 
% Por lo tanto, g(2t +1) debería activarse cuando 2t+1 = 0 o en t=−0.5, un
% hecho nuevamente confirmado,
%
% Considere trazar g(−t + 1) sobre (−2 ≤ t ≤ 2). 
% Como a < 0, la forma de onda será reflejada. Agregar la condición b > 0 desplaza la forma de onda final hacia la derecha.
plot(t,g(-t+1)); xlabel('t'); ylabel('g(-t+1)'); grid;

%%
% Hasta este punto, las gráficas anteriores pueden ser graficadas
% razonablemente a mano.
% Considere la posibilidad de trazar la función más complicada h(t) = g(2t + 1) + g(−t + 1) sobre (−2 ≤ t ≤ 2) un boceto a mano preciso sería bastante difícil. 
% Con MATLAB, el trabajo es mucho menos pesado.
plot(t,g(2*t+1)+g(-t+1)); xlabel('t'); ylabel('h(t)'); grid;

%%
% 1.11-4 Integración numérica y estimación de la energía de la señal
%
% Las señales interesantes suelen tener representaciones matemáticas no triviales.
% Computar la energía de la señal, que implica integrar el cuadrado de estas expresiones, puede ser una tarea desalentadora. 
% Afortunadamente, muchas integrales difíciles se pueden estimar con precisión mediante técnicas de integración numérica.
%
% Incluso si la integración parece simple, la integración numérica proporciona una buena manera de verificar resultados analíticos.
%
% Para empezar, considere la señal simple $$x(t) = e^{-t} (u(t)-u(t-1))$$.
% La energía de x(t) se expresa como $$Ex = \int_{-\infty}^{\infty} |x(t)|^2 dt = \int_{0}^{1} e^{-2t}dt$$.
% Integrando rendimientos $$Ex = 0.5(1-e^{-2}) = 0.4323$$.
% La energía integral también se puede evaluar numéricamente.
% Evaluar el integrando en puntos uniformemente separados por t, multiplicar cada uno por t para calcular las áreas del rectángulo y luego sumar todos los rectángulos. 
% Primero, creamos la función x(t).
x = @(t) exp(-t).*((t>=0)&(t<1));

%%
% Con t = 0,01 se crea un vector de tiempo adecuado.
t=(0:0.01:1);

%%
% El resultado final es computado usango el comando sum:
E_x = sum(x(t).*x(t)*0.01)

%%
% El resultado no es perfecto, pero con un error relativo del 1% está cerca. 
% Reduciendo t, la aproximación mejora. 
% Por ejemplo, t = 0,001 produce E_x = 0,4328, o un error relativo del 0,1%.
%
% Aunque es fácil de visualizar, la aproximación rectangular no es la mejor técnica de integración numérica. 
% La función quad de MATLAB implementa una mejor técnica de integración numérica llamada cuadratura de Simpson adaptativa recursiva.
% Para operar, quad requiere una función que describa el integrando, el límite inferior de integración y el límite superior de integración. 
% Observe que no es necesario especificar.
%
% Para utilizar quad para estimar Ex, primero se debe describir el integrando.
x_squared = @(t) x(t).*x(t);

%%
% Estimando Ex, le sigue:
E_x = quad(x_squared,0,1)

%%
% En este caso el error relativo es de -0.0026%.
% Se pueden utilizar las mismas técnicas para estimar la energía de señales
% más complejas. Considerar g(t), definido previamente.
% La energía está expresada como $$Eg = \int_{0}^{\infty} e^{-2t}cos^2(2 \pi t) dt$$.
% Una solución de forma cerrada existe, pero requiere algo de esfuerzo. 
% MATLAB proporciona una respuesta más rápidamente.
g_squared = @(t) g(t).*g(t);

%%
% Aunque el límite superior de integración es infinito, la envolvente que decae exponencialmente asegura g(t) es efectivamente cero mucho antes de t = 100. 
% Por lo tanto, se utiliza un límite superior de t = 100 junto con t = 0,001.
t = (0:0.001:100);
E_g = sum(g_squared(t)*0.001)

%%
% Se obtiene una aproximación ligeramente mejor con la función quad.
E_g = quad(g_squared,0,100)

%%
% EJERCICIO 1.21 Cálculo de la energía de la señal con MATLAB
%
% Utilice MATLAB para confirmar que la energía de la señal h(t), definida previamente como h(t) = g(2t+1)+g(−t+1), es Eh = 0.3768.
h = @(t) g(2*t+1)+g(-t+1);
h_squared = @(t) h(t).*h(t);
E_h = quad(h_squared,-100,100)

%% Problema 2
%
% Resolver el problema 1.2-2 usando las herramientas del problema anterior.
%
% 1.2-2 Para la señal $$x(t)$$ mostrada a continuación, graficar:
%
% *(a)* $$x(t-4)$$
%
% *(b)* $$x(t/1.5)$$
%
% *(c)* $$x(-t)$$
%
% *(d)* $$x(2t-4)$$
%
% *(e)* $$x(2-t)$$
%
% <<P1.2-2.png>>
% 
% Tenemos que la función x(t) = -t.*(u(t+4)-u(t)) + t.*(u(t)-u(t-2))
t = (-10:0.01:10);
x = @(t) -t.*(u(t+4)-u(t)) + t.*(u(t)-u(t-2));
plot(t,x(t)); xlabel('t'); ylabel('x(t)'); grid;

%%
% Vamos a graficar las 5 gráficas solicitadas en un subploat de 3x2 con su
% identificador correspondiente a cada gráfica:
figure()
subplot(3,2,1)
plot(t,x(t-4),'LineWidth',2); title('(a)'); xlabel('t'); ylabel('x(t-4)'); grid; axis([-5 7,0,5])
subplot(3,2,2)
plot(t,x(t/1.5),'r','LineWidth',2); title('(b)'); xlabel('t'); ylabel('x(t/1.5)'); grid; axis([-7 5,0,5])
subplot(3,2,3)
plot(t,x(-t),'k','LineWidth',2); title('(c)'); xlabel('t'); ylabel('x(-t)'); grid; axis([-6 6,0,5])
subplot(3,2,4)
plot(t,x(t.*2-4),'m','LineWidth',2); title('(d)'); xlabel('t'); ylabel('x(2t-4)'); grid; axis([-6 6,0,5])
subplot(3,2,5)
plot(t,x(2-t),'c','LineWidth',2); title('(e)'); xlabel('t'); ylabel('x(2-t)'); grid; axis([-5 7,0,5])

%% Problema 3
%
% Resolver el problema 1.11-1, los ejes deben mostrarse en el origen además de la edición de tu preferencia.
%
% 1.11-1 Proporcionar el código  de MATLAB y  los resultados que tracen la porción impar Xo(t) de la función $$x(t) = 2^{-t} cos(2 \pi t) u(t - \pi)$$ en un intervalo de longitud adecuada utilizando un número adecuado de puntos.
%
% Tenmos que $$x(t) = 2^{-t} cos(2 \pi t) u(t - \pi)$$
figure()
x = @(t) (2.^(-t)).*cos(2.*pi.*t).*u(t-pi);
t = (-10:0.01:10);
plot(t,x(t),'LineWidth',1); title('Problema 1.11-1'); xlabel('t'); ylabel('x(t)'); grid; axis([2 10,-0.09,0.09])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

%%
% Ahora se graficará la parte impar de la señal
figure()
Xo = @(t) (x(t) - x(-t))/2;
plot(t,Xo(t),'r','LineWidth',1); title('Problema 1.11-1 parte impar'); xlabel('t'); ylabel('Xo(t)'); grid; axis([-10 10,-0.05,0.05])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

%% Problema 4
%
% Construye la gráfica de: $$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$  para cuatro rangos (figura 2x2).
% Los ejes deben mostrarse en el origen ademas de la edición de su preferencia.
x = @(t) cos(2.*pi.*1.*t) + cos(2.*pi.*2.*t) + cos(2.*pi.*3.*t) + cos(2.*pi.*4.*t) + cos(2.*pi.*5.*t) + cos(2.*pi.*6.*t) + cos(2.*pi.*7.*t) + cos(2.*pi.*8.*t) + cos(2.*pi.*9.*t) + cos(2.*pi.*10.*t);
figure()
subplot(2,2,1)
plot(t,x(t),'LineWidth',0.3); title('Función x(t) de -3 a 3'); xlabel('t'); ylabel('x(t)'); grid; axis([-3 3,-3,10])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

subplot(2,2,2)
plot(t,x(t),'r','LineWidth',0.3); title('Función x(t) de 0 a 1'); xlabel('t'); ylabel('x(t)'); grid; axis([0 1,-3,10])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

subplot(2,2,3)
plot(t,x(t),'g','LineWidth',0.3); title('Función x(t) de 2 a 5'); xlabel('t'); ylabel('x(t)'); grid; axis([2 5,-3,10])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

subplot(2,2,4)
plot(t,x(t),'k','LineWidth',0.3); title('Función x(t) de -1 a 1'); xlabel('t'); ylabel('x(t)'); grid; axis([-1 1,-3,10])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

%% Problema 5
%
% Resolver el problema 1.11-3, agregar como inciso (e) la gráfica de
% $x(t)$ para $t\in[-10,10]$.
%
% 1.11-3 Define $$x(t) = e^{t(1+j2\pi)}u(-t)$$ y $$y(t) = Re\{2x(\frac{-5-t} 2 \}$$
%
% *(a)* Utilice MATLAB para graficar $$Re \{ x(t) \}$$ con respecto $$Im \{ x(at) \}$$ para $$a = 0.5, 1, 2$$ y $$-10 <= t <=10$$ ¿Qué importante es el factor escalar $$a$$ en la forma de la figura resultante? 
%
% *(b)* Utilice MATLAB para graficar $$y(t)$$ sobre $$-10 <= t <=10$$ Determine analíticamente el tiempo $$t_0$$ donde y(t) tiene una discontinuidad de salto. 
% Verifique su cálculo de $$t_0$$ utilizando la gráfica de y(t).
%
% *(c)* Utilice MATLAB y la integración numérica para calcular la energía $$E_x$$ de la señal $$x(t)$$.
%
% *(d)* Utilice MATLAB y la integración numérica para calcular la energía $$E_y$$ de la señal $$y(t)$$.
%
% *(e)* Graficar $x(t)$ para $t\in[-10,10]$.
%
%
% *(a)*


t=(-10:0.01:10);
a = [0.5, 1, 2];
x = @(t) exp(t.*(1+(2*pi*1j))).*u(-t);
y = @(t) real(2*x((-5-t)/2));
xr = real(x(t));
xi = imag (x(a(1)*t));

figure()
plot(xi,xr,'LineWidth',0.3); title('Inciso (a) con a = 0.5'); xlabel('Im\{x(at)\}'); ylabel('Re\{x(t)\}'); grid; axis([-1 1,-1.1,1.1])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

figure()
xi = imag (x(a(2)*t));
plot(xi,xr,'LineWidth',0.3); title('Inciso (a) con a = 1'); xlabel('Im\{x(at)\}'); ylabel('Re\{x(t)\}'); grid; axis([-1 1,-1.1,1.1])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

figure()
xi = imag (x(a(3)*t));
plot(xi,xr,'LineWidth',0.3); title('Inciso (a) con a = 2'); xlabel('Im\{x(at)\}'); ylabel('Re\{x(t)\}'); grid; axis([-1 1,-1.1,1.1])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

%%
%
% *(b)*
figure()
t = (-10:0.01:10);
plot(t,y(t),'LineWidth',0.3); title('Inciso (b)'); xlabel('t'); ylabel('y(t)'); grid; axis([-10 10,-2.5,2.5])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

%%
% Comprobando analinitcamente la discontinuidad $$t_0$$ si $$y(t) = Re\{2x(\frac{-5-t} 2 \}$$
dis = find(diff(y(t)));
t0 = t(dis(1))

%%
%
% *(c)*
fun = @(t) abs(x(t)).^2;
Ex = integral(fun,-Inf,Inf)

%%
%
% *(d)*
fun2 = @(t) abs(y(t)).^2;
Ey = integral(fun2,-Inf,Inf)

%%
%
% *(e)*
figure()
t = (-10:0.01:10);
plot(t,x(t),'LineWidth',0.3); title('Inciso (e)'); xlabel('t'); ylabel('x(t)'); grid; axis([-10 10,-1.1,1.1])
ax = gca;
ax.XAxisLocation = 'origin';
ax.YAxisLocation = 'origin';
ax.Box = 'off';

%% Problema 6
%
% Construir una app que permita:
%
% * Gráficar señales en tiempo continuo reales, el usuario ingresa la
% definición de la señal en el formato especifico.
% * El usuario puede definir el intervalo de la gráfica.
% * El usuario puede seleccionar el tipo de transformación (horizontal,
% vertical o combinación) que desee realizar a la señal, la app deberá
% mostrar la gráfica de esta transformación.
% * Se adjunta una imagen de la app a la práctica, y el archivo de la app.
% 
% <<app.png>>
% 

%

##### SOURCE END #####
-->
</body>
</html>
